// Generated by CoffeeScript 1.10.0
(function() {
  var GameOfLife,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  GameOfLife = (function() {
    GameOfLife.prototype.currentCellGeneration = null;

    GameOfLife.prototype.cellSize = 10;

    GameOfLife.prototype.numberOfRows = 50;

    GameOfLife.prototype.numberOfColumns = 50;

    GameOfLife.prototype.seedProbability = 0.5;

    GameOfLife.prototype.tickLength = 100;

    GameOfLife.prototype.canvas = null;

    GameOfLife.prototype.drawingContext = null;

    GameOfLife.prototype.run = false;

    function GameOfLife() {
      this.tick = bind(this.tick, this);
      this.createCanvas();
      this.resizeCanvas();
      this.createDrawingContext();
      this.seed();
      this.tick();
    }

    GameOfLife.prototype.createCanvas = function() {
      this.canvas = document.createElement('canvas');
      document.body.appendChild(this.canvas);
      return this.canvas.addEventListener("click", (function(_this) {
        return function(e) {
          return _this.click(e);
        };
      })(this));
    };

    GameOfLife.prototype.resizeCanvas = function() {
      this.canvas.height = this.cellSize * this.numberOfRows;
      return this.canvas.width = this.cellSize * this.numberOfColumns;
    };

    GameOfLife.prototype.createDrawingContext = function() {
      return this.drawingContext = this.canvas.getContext('2d');
    };

    GameOfLife.prototype.seed = function() {
      var column, i, ref, results, row, seedCell;
      this.currentCellGeneration = [];
      results = [];
      for (row = i = 0, ref = this.numberOfRows; 0 <= ref ? i < ref : i > ref; row = 0 <= ref ? ++i : --i) {
        this.currentCellGeneration[row] = [];
        results.push((function() {
          var j, ref1, results1;
          results1 = [];
          for (column = j = 0, ref1 = this.numberOfColumns; 0 <= ref1 ? j < ref1 : j > ref1; column = 0 <= ref1 ? ++j : --j) {
            seedCell = this.createSeedCell(row, column);
            results1.push(this.currentCellGeneration[row][column] = seedCell);
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    GameOfLife.prototype.createSeedCell = function(row, column) {
      return {
        isAlive: Math.random() < this.seedProbability,
        row: row,
        column: column
      };
    };

    GameOfLife.prototype.tick = function() {
      this.drawGrid();
      this.evolveCellGeneration();
      if (this.run) {
        return setTimeout(this.tick, this.tickLength);
      } else {
        return console.log("Not running");
      }
    };

    GameOfLife.prototype.drawGrid = function() {
      var column, i, ref, results, row;
      results = [];
      for (row = i = 0, ref = this.numberOfRows; 0 <= ref ? i < ref : i > ref; row = 0 <= ref ? ++i : --i) {
        results.push((function() {
          var j, ref1, results1;
          results1 = [];
          for (column = j = 0, ref1 = this.numberOfColumns; 0 <= ref1 ? j < ref1 : j > ref1; column = 0 <= ref1 ? ++j : --j) {
            results1.push(this.drawCell(this.currentCellGeneration[row][column]));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    GameOfLife.prototype.drawCell = function(cell) {
      var fillStyle, x, y;
      x = cell.column * this.cellSize;
      y = cell.row * this.cellSize;
      if (cell.isAlive) {
        fillStyle = 'rgb(242, 198, 65)';
      } else {
        fillStyle = 'rgb(38, 38, 38)';
      }
      this.drawingContext.strokeStyle = 'rgba(242, 198, 65, 0.5)';
      this.drawingContext.strokeRect(x, y, this.cellSize, this.cellSize);
      this.drawingContext.fillStyle = fillStyle;
      return this.drawingContext.fillRect(x, y, this.cellSize, this.cellSize);
    };

    GameOfLife.prototype.evolveCellGeneration = function() {
      var column, evolvedCell, i, j, newCellGeneration, ref, ref1, row;
      newCellGeneration = [];
      for (row = i = 0, ref = this.numberOfRows; 0 <= ref ? i < ref : i > ref; row = 0 <= ref ? ++i : --i) {
        newCellGeneration[row] = [];
        for (column = j = 0, ref1 = this.numberOfColumns; 0 <= ref1 ? j < ref1 : j > ref1; column = 0 <= ref1 ? ++j : --j) {
          evolvedCell = this.evolveCell(this.currentCellGeneration[row][column]);
          newCellGeneration[row][column] = evolvedCell;
        }
      }
      return this.currentCellGeneration = newCellGeneration;
    };

    GameOfLife.prototype.evolveCell = function(cell) {
      var evolvedCell, numberOfAliveNeighbors;
      evolvedCell = {
        row: cell.row,
        column: cell.column,
        isAlive: cell.isAlive
      };
      numberOfAliveNeighbors = this.countAliveNeighbors(cell);
      if (cell.isAlive || numberOfAliveNeighbors === 3) {
        evolvedCell.isAlive = (1 < numberOfAliveNeighbors && numberOfAliveNeighbors < 4);
      }
      return evolvedCell;
    };

    GameOfLife.prototype.countAliveNeighbors = function(cell) {
      var column, i, j, lowerColumnBound, lowerRowBound, numberOfAliveNeighbors, ref, ref1, ref2, ref3, row, upperColumnBound, upperRowBound;
      lowerRowBound = Math.max(cell.row - 1, 0);
      upperRowBound = Math.min(cell.row + 1, this.numberOfRows - 1);
      lowerColumnBound = Math.max(cell.column - 1, 0);
      upperColumnBound = Math.min(cell.column + 1, this.numberOfColumns - 1);
      numberOfAliveNeighbors = 0;
      for (row = i = ref = lowerRowBound, ref1 = upperRowBound; ref <= ref1 ? i <= ref1 : i >= ref1; row = ref <= ref1 ? ++i : --i) {
        for (column = j = ref2 = lowerColumnBound, ref3 = upperColumnBound; ref2 <= ref3 ? j <= ref3 : j >= ref3; column = ref2 <= ref3 ? ++j : --j) {
          if (row === cell.row && column === cell.column) {
            continue;
          }
          if (this.currentCellGeneration[row][column].isAlive) {
            numberOfAliveNeighbors++;
          }
        }
      }
      return numberOfAliveNeighbors;
    };

    GameOfLife.prototype.start = function() {
      console.log("Start");
      this.run = true;
      return setTimeout(this.tick, this.tickLength);
    };

    GameOfLife.prototype.stop = function() {
      console.log("Stop");
      return this.run = false;
    };

    GameOfLife.prototype.clear = function() {
      var column, i, j, ref, ref1, row;
      for (row = i = 0, ref = this.numberOfRows; 0 <= ref ? i < ref : i > ref; row = 0 <= ref ? ++i : --i) {
        for (column = j = 0, ref1 = this.numberOfColumns; 0 <= ref1 ? j < ref1 : j > ref1; column = 0 <= ref1 ? ++j : --j) {
          this.currentCellGeneration[row][column].isAlive = 0;
        }
      }
      return this.drawGrid();
    };

    GameOfLife.prototype.reseed = function() {
      this.seed();
      return this.drawGrid();
    };

    GameOfLife.prototype.click = function(e) {
      var col, row, x, y;
      x = e.clientX - this.canvas.offsetLeft;
      y = e.clientY - this.canvas.offsetTop - 2;
      row = Math.floor(y / this.cellSize);
      col = Math.floor(x / this.cellSize);
      console.log(e);
      console.log("Click! " + col + ', ' + row);
      this.currentCellGeneration[row][col].isAlive = !this.currentCellGeneration[row][col].isAlive;
      return this.drawGrid();
    };

    return GameOfLife;

  })();

  window.GameOfLife = GameOfLife;

}).call(this);
